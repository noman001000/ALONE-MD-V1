
const { zokou } = require('../framework/zokou');
const Heroku = require('heroku-client');
const s = require("../set");
const axios = require("axios");
const speed = require("performance-now");
const { exec } = require("child_process");
const conf = require(__dirname + "/../set");
const { dare, truth, random_question, amount_of_questions } = require('../Database/truth-dare.js');
// Function for delay simulation
function delay(ms) {
  console.log(`â±ï¸ delay for ${ms}ms`);
  return new Promise(resolve => setTimeout(resolve, ms));
}
// Format the uptime into a human-readable string
function runtime(seconds) {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secondsLeft = Math.floor(seconds % 60);

  return `${hours}h ${minutes}m ${secondsLeft}s`;
}

// New loading animation with different symbols and larger progress bar
async function loading(dest, zk) {
  const lod = [
    "â¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬›â¬›ê§20%ê§‚",
    "â¬›â¬›â¬›â¬›â¬œâ¬œâ¬œâ¬œê§40%ê§‚",
    "â¬œâ¬œâ¬›â¬›â¬›â¬›â¬œâ¬œê§60%ê§‚",
    "â¬œâ¬œâ¬œâ¬œâ¬›â¬›â¬›â¬›ê§80%ê§‚",
    "â¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬›â¬›ê§100%ê§‚",
    "*LÒ‰OÒ‰AÒ‰DÒ‰IÒ‰NÒ‰GÒ‰ DÒ‰OÒ‰NÒ‰EÒ‰ áµ—Ê±áµƒáµ‘áµáµ§â‚’áµ¤ âš”ï¸ğŸ—¡ï¸*"
  ];

  let { key } = await zk.sendMessage(dest, { text: 'Loading Please Wait' });

  for (let i = 0; i < lod.length; i++) {
    await zk.sendMessage(dest, { text: lod[i], edit: key });
    await delay(500); // Adjust the speed of the animation here
  }
}

zokou({
  //nomCom: "test",
  aliases: ["alive", "testing"],
  categorie: "system",
  reaction: "âš”ï¸"
}, async (dest, zk, commandeOptions) => {
  const { ms } = commandeOptions;

  // Array of sound file URLs
  const audioFiles = [
    'https://files.catbox.moe/hpwsi2.mp3',
    'https://files.catbox.moe/xci982.mp3',
    'https://files.catbox.moe/utbujd.mp3',
    'https://files.catbox.moe/w2j17k.m4a',
    'https://files.catbox.moe/851skv.m4a',
    'https://files.catbox.moe/qnhtbu.m4a',
    'https://files.catbox.moe/lb0x7w.mp3',
    'https://files.catbox.moe/efmcxm.mp3',
    'https://files.catbox.moe/gco5bq.mp3',
    'https://files.catbox.moe/26oeeh.mp3',
    'https://files.catbox.moe/a1sh4u.mp3',
    'https://files.catbox.moe/vuuvwn.m4a',
    'https://files.catbox.moe/wx8q6h.mp3',
    'https://files.catbox.moe/uj8fps.m4a',
    'https://files.catbox.moe/dc88bx.m4a',
    'https://files.catbox.moe/tn32z0.m4a'
  ];

  // Randomly pick an audio file from the list
  const selectedAudio = audioFiles[Math.floor(Math.random() * audioFiles.length)];

  // Audio message object
  const audioMessage = {
    audio: {
      url: selectedAudio,
    },
    mimetype: 'audio/mpeg',
    ptt: true,  // Marking this as a "Push-to-Talk" message
    waveform: [100, 0, 100, 0, 100, 0, 100],
    fileName: 'shizo',
    contextInfo: {
      externalAdReply: {
        title: 'ğ—œ ğ—”ğ—  ğ—”ğ—Ÿğ—œğ—©ğ—˜ ğ— ğ—¢ğ—§ğ—›ğ—˜ğ—¥ğ—™ğ—¨ğ—–ğ—ğ—˜ğ—¥',
        body: conf.OWNER_NAME,
        thumbnailUrl: conf.URL,
        sourceUrl: conf.GURL, // Corrected variable name
        mediaType: 1,
        renderLargerThumbnail: true,
      },
    },
  };

  // Send the audio message with the context of the original message
  await zk.sendMessage(dest, audioMessage, { quoted: ms });
});


zokou({
  nomCom: 'restart',
  aliases: ['reboot'],
  categorie: "system"
}, async (chatId, zk, context) => {
  const { repondre, superUser } = context;

  // Check if the user is a super user
  if (!superUser) {
    return repondre("You need owner privileges to execute this command!");
  }

  try {
    // Inform the user that the bot is restarting
    await repondre("*Restarting...*");

    // Function to create a delay
    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    // Wait for 3 seconds before restarting
    await sleep(3000);

    // Exit the process to restart the bot
    process.exit();
  } catch (error) {
    console.error("Error during restart:", error);
  }
});
// thanks  chatgpt


// Command to retrieve Heroku config vars
zokou({
  nomCom: 'allvar',
  categorie: "system"
}, async (chatId, zk, context) => {
  const { repondre, superUser } = context;

  // Check if the command is issued by the owner
  if (!superUser) {
    return repondre("*This command is restricted to the bot owner or Alone owner ğŸ’€*");
  }

  const appname = s.HEROKU_APP_NAME;
  const herokuapi = s.HEROKU_API_KEY;

  const heroku = new Heroku({
    token: herokuapi,
  });

  const baseURI = `/apps/${appname}/config-vars`;

  try {
    // Fetch config vars from Heroku API
    const configVars = await heroku.get(baseURI);

    let str = '*â•­â”€â”€â”€à¼ºAll my Heroku varsà¼»â”€â”€â”€â”€â•®*\n\n';
    
    // Loop through the returned config vars and format them
    for (let key in configVars) {
      if (configVars.hasOwnProperty(key)) {
        str += `â˜… *${key}* = ${configVars[key]}\n`;
      }
    }

    // Send the formatted response back to the user
    repondre(str);

  } catch (error) {
    console.error('Error fetching Heroku config vars:', error);
    repondre('Sorry, there was an error fetching the config vars.');
  }
});

// Command to set a Heroku config var
zokou({
  nomCom: 'setvar',
  categorie: "system"
}, async (chatId, zk, context) => {
  const { repondre, superUser, arg } = context;

  // Check if the command is issued by the owner
  if (!superUser) {
    return repondre("*This command is restricted to the bot owner or Alone owner ğŸ’€*");
  }

  const appname = s.HEROKU_APP_NAME;
  const herokuapi = s.HEROKU_API_KEY;

  if (!arg || arg.length !== 1 || !arg[0].includes('=')) {
    return repondre('Incorrect Usage:\nProvide the key and value correctly.\nExample: setvar ANTICALL=yes');
  }

  const [key, value] = arg[0].split('=');

  const heroku = new Heroku({
    token: herokuapi,
  });

  const baseURI = `/apps/${appname}/config-vars`;

  try {
    // Set the new config var
    await heroku.patch(baseURI, {
      body: {
        [key]: value,
      },
    });

    // Notify success
    await repondre(`*âœ… The variable ${key} = ${value} has been set successfully. The bot is restarting...*`);
  } catch (error) {
    console.error('Error setting config variable:', error);
    await repondre(`âŒ There was an error setting the variable. Please try again later.\n${error.message}`);
  }
});

zokou({
  nomCom: "shell",
  aliases: ["getcmd", "cmd"],
  reaction: 'âš”ï¸',
  categorie: "system"
}, async (context, message, params) => {
  const { repondre: sendResponse, arg: commandArgs, superUser: Owner, auteurMessage } = params;

  // Ensure that the sender is the superuser (Owner)
  if (!Owner) {
    return sendResponse("You are not authorized to execute shell commands.");
  }

  const command = commandArgs.join(" ").trim();

  // Ensure the command is not empty
  if (!command) {
    return sendResponse("Please provide a valid shell command.");
  }

  // Execute the shell command
  exec(command, (err, stdout, stderr) => {
    if (err) {
      return sendResponse(`Error: ${err.message}`);
    }

    if (stderr) {
      return sendResponse(`stderr: ${stderr}`);
    }

    if (stdout) {
      return sendResponse(stdout);
    }

    // If there's no output, let the user know
    return sendResponse("Command executed successfully, but no output was returned.");
  });
});

zokou(
  {
   // nomCom: 'ping',
    aliases: ['speed', 'latency'],
    desc: 'To check bot response time',
    categorie: 'system', // Fixed the typo here (Categorie -> categorie)
    reaction: 'âš¡',
    fromMe: true, // Removed quotes to make it a boolean
  },
  async (dest, zk) => {
    // Call the new loading animation without delaying the rest of the bot
    const loadingPromise = loading(dest, zk);

    // Generate 3 ping results with large random numbers for a more noticeable effect
    const pingResults = Array.from({ length: 3 }, () => Math.floor(Math.random() * 10000 + 1000));

    // Create larger font for ping results (using special characters for a bigger look)
    const formattedResults = pingResults.map(ping => `${conf.OWNER_NAME} ğ–˜ğ–•ğ–Šğ–Šğ–‰ ${ping} ğŒ/ğ’  `);

    // Send the ping results with the updated text and format
    await zk.sendMessage(dest, {
      text: `${formattedResults.join(', ')}`,
      contextInfo: {
        externalAdReply: {
          title: conf.BOT,
          body: `${formattedResults.join(" | ")}`,
          thumbnailUrl: conf.URL, // Replace with your bot profile photo URL
          sourceUrl: conf.GURL, // Your channel URL
          mediaType: 1,
          showAdAttribution: true, // Verified badge
        },
      },
    });

    console.log("Ping results sent successfully with new loading animation and formatted results!");

    // Ensure loading animation completes after the ping results
    await loadingPromise;
  }
);

// React function if needed for further interaction
function react(dest, zk, msg, reaction) {
  zk.sendMessage(dest, { react: { text: reaction, key: msg.key } });
}

zokou({
  nomCom: 'runtime',
  aliases: ['logs', 'running'],
  desc: 'To check runtime',
  categorie: 'system', // Fixed the typo here (Categorie -> categorie)
  reaction: 'âš”ï¸',
  fromMe: true, // Removed quotes to make it a boolean
}, async (dest, zk, commandeOptions) => {
  const { ms, arg, repondre } = commandeOptions;

  // Get bot's runtime
  const botUptime = process.uptime(); // Get the bot uptime in seconds

  // Send uptime information to the user
  await zk.sendMessage(dest, {
    text: `*${conf.OWNER_NAME} UPTIME IS ${runtime(botUptime)}*`,
    contextInfo: {
      externalAdReply: {
        title: `${conf.BOT} UPTIME`,
        body: `Bot Uptime: ${runtime(botUptime)}`, // Format the uptime before sending
        thumbnailUrl: conf.URL, // Replace with your bot profile photo URL
        sourceUrl: conf.GURL, // Your channel URL
        mediaType: 1,
        showAdAttribution: true, // Verified badge
      },
    },
  });

  console.log("Runtime results sent successfully!");

  // Ensure loading animation completes after sending the uptime message
  await delay(ms); // Await the delay to simulate the loading animation
});

// React function to allow interaction after sending message
function react(dest, zk, msg, reaction) {
  zk.sendMessage(dest, { react: { text: reaction, key: msg.key } });
}


zokou({
  nomCom: 'update',
  aliases: ['redeploy', 'sync'],
  categorie: "system"
}, async (chatId, zk, context) => {
  const { repondre, superUser } = context;

  // Check if the command is issued by the owner
  if (!superUser) {
    return repondre("*This command is restricted to the bot owner or Alpha owner ğŸ’€*");
  }

  // Ensure Heroku app name and API key are set
  const herokuAppName = s.HEROKU_APP_NAME;
  const herokuApiKey = s.HEROKU_API_KEY;

  // Check if Heroku app name and API key are set in environment variables
  if (!herokuAppName || !herokuApiKey) {
    await repondre("It looks like the Heroku app name or API key is not set. Please make sure you have set the `HEROKU_APP_NAME` and `HEROKU_API_KEY` environment variables.");
    return;
  }

  // Function to redeploy the app
  async function redeployApp() {
    try {
      const response = await axios.post(
        `https://api.heroku.com/apps/${herokuAppName}/builds`,
        {
          source_blob: {
            url: "https://github.com/Toputech/ALONE-MD-V1/tarball/main",
          },
        },
        {
          headers: {
            Authorization: `Bearer ${herokuApiKey}`,
            Accept: "application/vnd.heroku+json; version=3",
          },
        }
      );

      // Notify the user about the update and redeployment
      await repondre("*Your bot is getting updated, wait 2 minutes for the redeploy to finish! This will install the latest version of ALONE-MD.*");
      console.log("Build details:", response.data);
    } catch (error) {
      // Handle any errors during the redeployment process
      const errorMessage = error.response?.data || error.message;
      await repondre(`*Failed to update and redeploy. ${errorMessage} Please check if you have set the Heroku API key and Heroku app name correctly.*`);
      console.error("Error triggering redeploy:", errorMessage);
    }
  }

  // Trigger the redeployment function
  redeployApp();
});

zokou({
  nomCom: "advice",
  aliases: ["wisdom", "wise"],
  reaction: "ğŸ—¨ï¸",
  categorie: "system"
}, async (dest, zk, context) => {
  const { reply: replyToUser, ms: messageQuote } = context;
  try {
    // Get advice from the API using axios
    const response = await axios.get("https://api.adviceslip.com/advice");
    const advice = response.data.slip.advice;

    // Send the advice with ad reply
    await zk.sendMessage(dest, {
      text: `Here is your advice: ${advice} ğŸ™ƒ`,
      contextInfo: {
        externalAdReply: {
          title: "Daily Dose of Advice",
          body: "Hereâ€™s a little nugget of wisdom to brighten your day!",
          thumbnailUrl: conf.URL,
          sourceUrl: conf.GURL,
          mediaType: 1,
          showAdAttribution: true
        }
      }
    }, { quoted: messageQuote });
  } catch (error) {
    console.error("Error fetching advice:", error.message || "An error occurred");
    await replyToUser("Oops, an error occurred while processing your request.");
  }
})
  zokou({
  nomCom: "fetch",
  aliases: ["get", "find"],
  categorie: "system",
  reaction: 'ğŸ›„',
}, async (sender, zk, context) => {
  const { repondre: sendResponse, arg: args } = context;
  const urlInput = args.join(" ");

  // Check if URL starts with http:// or https://
  if (!/^https?:\/\//.test(urlInput)) {
    return sendResponse("Start the *URL* with http:// or https://");
  }

  try {
    const url = new URL(urlInput);
    const fetchUrl = `${url.origin}${url.pathname}?${url.searchParams.toString()}`;
    
    // Fetch the URL content
    const response = await axios.get(fetchUrl, { responseType: 'arraybuffer' });

    // Check if the response is okay
    if (response.status !== 200) {
      return sendResponse(`Failed to fetch the URL. Status: ${response.status} ${response.statusText}`);
    }

    const contentLength = response.headers['content-length'];
    if (contentLength && parseInt(contentLength) > 104857600) {
      return sendResponse(`Content-Length exceeds the limit: ${contentLength}`);
    }

    const contentType = response.headers['content-type'];
    console.log('Content-Type:', contentType);

    // Fetch the response as a buffer
    const buffer = Buffer.from(response.data);

    // Handle different content types
    if (/image\/.*/.test(contentType)) {
      // Send image message
      await zk.sendMessage(sender, {
        image: { url: fetchUrl },
        caption: `> > *${conf.BOT}*`
      }, { quoted: context.ms });
    } else if (/video\/.*/.test(contentType)) {
      // Send video message
      await zk.sendMessage(sender, {
        video: { url: fetchUrl },
        caption: `> > *${conf.BOT}*`
      }, { quoted: context.ms });
    } else if (/audio\/.*/.test(contentType)) {
      // Send audio message
      await zk.sendMessage(sender, {
        audio: { url: fetchUrl },
        caption: `> > *${conf.BOT}*`
      }, { quoted: context.ms });
    } else if (/text|json/.test(contentType)) {
      try {
        // Try parsing the content as JSON
        const json = JSON.parse(buffer);
        console.log("Parsed JSON:", json);
        sendResponse(JSON.stringify(json, null, 10000)); // Limit response size to 10000 characters
      } catch {
        // If parsing fails, send the raw text response
        sendResponse(buffer.toString().slice(0, 10000)); // Limit response size to 10000 characters
      }
    } else {
      // Send other types of documents
      await zk.sendMessage(sender, {
        document: { url: fetchUrl },
        caption: `> > *${conf.BOT}*`
      }, { quoted: context.ms });
    }
  } catch (error) {
    console.error("Error fetching data:", error.message);
    sendResponse(`Error fetching data: ${error.message}`);
  }
})

zokou({
  //nomCom: "advice",
  aliases: ["wisdom", "wise"],
  reaction: "ğŸ—¨ï¸",
  categorie: "Fun"
}, async (dest, zk, context) => {
  const { reply: replyToUser, ms: messageQuote } = context;
  try {
    // Get advice from the API using axios
    const response = await axios.get("https://api.adviceslip.com/advice");
    const advice = response.data.slip.advice;

    // Send the advice with ad reply
    await zk.sendMessage(dest, {
      text: `Here is your advice: ${advice} ğŸ˜Š`,
      contextInfo: {
        externalAdReply: {
          title: "Daily Dose of Advice",
          body: "Hereâ€™s a little nugget of wisdom to brighten your day!",
          thumbnailUrl: conf.URL,
          sourceUrl: conf.GURL,
          mediaType: 1,
          showAdAttribution: true
        }
      }
    }, { quoted: messageQuote });
  } catch (error) {
    console.error("Error fetching advice:", error.message || "An error occurred");
    await replyToUser("Oops, an error occurred while processing your request.");
  }
});

zokou({
  nomCom: "trivia",
  reaction: 'ğŸ¤”',
  categorie: 'Fun'
}, async (dest, zk, context) => {
  const { reply: replyToUser, prefix: prefix, ms: messageQuote } = context;
  try {
    // Fetch trivia question using axios
    const response = await axios.get("https://opentdb.com/api.php?amount=1&type=multiple");
    if (response.status !== 200) {
      return replyToUser("Invalid response from the trivia API. Status code: " + response.status);
    }

    const trivia = response.data.results[0];
    const question = trivia.question;
    const correctAnswer = trivia.correct_answer;
    const answers = [...trivia.incorrect_answers, correctAnswer].sort();

    // Format answer choices
    const answerChoices = answers.map((answer, index) => `${index + 1}. ${answer}`).join("\n");

    // Send trivia question with answer choices
    await zk.sendMessage(dest, {
      text: `Here's a trivia question for you: \n\n${question}\n\n${answerChoices}\n\nI will send the correct answer in 10 seconds...`,
      contextInfo: {
        externalAdReply: {
          title: "Trivia Time!",
          body: "Challenge yourself with this fun trivia question!",
          thumbnailUrl: conf.URL,
          sourceUrl: conf.GURL,
          mediaType: 1,
          showAdAttribution: true
        }
      }
    }, { quoted: messageQuote });

    // Send the correct answer after 10 seconds
    setTimeout(async () => {
      await zk.sendMessage(dest, {
        text: `The correct answer is: ${correctAnswer}`,
        contextInfo: {
          externalAdReply: {
            title: "Trivia Answer Revealed",
            body: "Did you get it right? Try another trivia question!",
            thumbnailUrl: conf.URL,
            sourceUrl: conf.GURL,
            mediaType: 1,
            showAdAttribution: true
          }
        }
      }, { quoted: messageQuote });
    }, 10000); // Delay for 10 seconds

  } catch (error) {
    console.error("Error getting trivia:", error.message);
    await zk.sendMessage(dest, {
      text: "Error getting trivia. Please try again later.",
      contextInfo: {
        externalAdReply: {
          title: "Trivia Error",
          body: "There was an error retrieving the trivia question. Please try again.",
          thumbnailUrl: conf.URL,
          sourceUrl: conf.GURL,
          mediaType: 1,
          showAdAttribution: true
        }
      }
    }, { quoted: messageQuote });
  }
});


zokou({
  nomCom: "question",
  categorie: "fun",
  reaction: "ğŸ¤¯"
}, async (dest, zk, commandeOptions) => {
  const { repondre, ms } = commandeOptions;
  try {
    // Respond with a random question
    await zk.sendMessage(dest, {
      text: random_question(),
      contextInfo: {
        externalAdReply: {
          title: "Random Question",
          body: "Here's a fun random question for you to ponder!",
          thumbnailUrl: conf.URL,
          sourceUrl: conf.GURL,
          mediaType: 1,
          showAdAttribution: true
        }
      }
    }, { quoted: ms });
  } catch (error) {
    console.error("Error while handling 'question' command:", error);
    await repondre("Sorry, something went wrong.");
  }
});

// Command for truth
zokou({
  nomCom: "truth",
  categorie: "fun",
  reaction: "ğŸ’š"
}, async (dest, zk, commandeOptions) => {
  const { repondre, ms } = commandeOptions;
  try {
    // Respond with a truth question
    await zk.sendMessage(dest, {
      text: truth(),
      contextInfo: {
        externalAdReply: {
          title: "Truth Question",
          body: "Here's a truth question to test your honesty!",
          thumbnailUrl: conf.URL,
          sourceUrl: conf.GURL,
          mediaType: 1,
          showAdAttribution: true
        }
      }
    }, { quoted: ms });
  } catch (error) {
    console.error("Error while handling 'truth' command:", error);
    await repondre("Sorry, something went wrong.");
  }
});

// Command for dare
zokou({
  nomCom: "dare",
  categorie: "fun",
  reaction: "ğŸ™„"
}, async (dest, zk, commandeOptions) => {
  const { repondre, ms } = commandeOptions;
  try {
    // Respond with a dare
    await zk.sendMessage(dest, {
      text: dare(),
      contextInfo: {
        externalAdReply: {
          title: "Dare Challenge",
          body: "Here's a dare to challenge your bravery!",
          thumbnailUrl: conf.URL,
          sourceUrl: conf.GURL,
          mediaType: 1,
          showAdAttribution: true
        }
      }
    }, { quoted: ms });
  } catch (error) {
    console.error("Error while handling 'dare' command:", error);
    await repondre("Sorry, something went wrong.");
  }
});

// Command for amount of questions
zokou({
  nomCom: "amountquiz",
  categorie: "fun",
  reaction: "ğŸ« "
}, async (dest, zk, commandeOptions) => {
  const { repondre, ms } = commandeOptions;
  try {
    // Call amount_of_questions with the desired type, defaulting to 0 (all questions)
    const totalQuestions = amount_of_questions(0);  // Change 0 to 1 or 2 depending on the desired category
    await zk.sendMessage(dest, {
      text: `${totalQuestions}`,
      contextInfo: {
        externalAdReply: {
          title: "Question Count",
          body: "Here's the total number of questions available!",
          thumbnailUrl: conf.URL,
          sourceUrl: conf.GURL,
          mediaType: 1,
          showAdAttribution: true
        }
      }
    }, { quoted: ms });
  } catch (error) {
    console.error("Error while handling 'amountquiz' command:", error);
    await repondre("Sorry, something went wrong.");
  }
});

zokou({
  //nomCom: "fact",
  reaction: 'âœŒï¸',
  categorie: "Fun"
}, async (dest, zk, context) => {
  const { repondre: respond, arg, ms } = context;

  try {
    const response = await axios.get("https://nekos.life/api/v2/fact");
    const data = response.data;
    const factMessage = `
â”â”â”â”â” *ALONE-MD-FACT* â”â”â”â”â”â—†                     
â”ƒ
â”ƒ   *â—‡* ${data.fact} 
â”ƒ
â”ƒ   *â—‡* Regards *ALONE MD*
â”ƒ      
 â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â—†
 â”‚ *_Powered by Toputech._*
 â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â—†
    `;

    await zk.sendMessage(dest, {
      text: factMessage,
      contextInfo: {
        externalAdReply: {
          title: "Fun Fact",
          body: "Here's a fun fact to enlighten your day!",
          thumbnailUrl: conf.URL,
          sourceUrl: conf.GURL,
          mediaType: 1,
          showAdAttribution: true
        }
      }
    }, { quoted: ms });
  } catch (error) {
    console.error(error);
    await respond("An error occurred while fetching the fact.");
  }
});

zokou({
  nomCom: "quotes",
  reaction: 'ğŸ’¥',
  categorie: "Fun"
}, async (dest, zk, context) => {
  const { repondre: respond, arg, ms } = context;

  try {
    const response = await axios.get("https://favqs.com/api/qotd");
    const data = response.data;
    const quoteMessage = `
â”â”â”â”â”â”QUOTEâ”â”â”â”â”â”â—†
â”ƒ   *â—‡* _${data.quote.body}_
â”ƒ  
â”ƒ   *â—‡* *AUTHOR:* ${data.quote.author}
â”ƒ      
â”ƒ    *â—‡*  *regards ALONE MD*
â”ƒ    
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â—†
â”‚ *_Powered by Toputech._*
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â—†
    `;

    await zk.sendMessage(dest, {
      text: quoteMessage,
      contextInfo: {
        externalAdReply: {
          title: "Daily Quote",
          body: "Here's an inspiring quote to motivate you!",
          thumbnailUrl: conf.URL,
          sourceUrl: conf.GURL,
          mediaType: 1,
          showAdAttribution: true
        }
      }
    }, { quoted: ms });
  } catch (error) {
    console.error(error);
    await respond("An error occurred while fetching the quote.");
  }
});

zokou({
  nomCom: "hack",
  aliases: ["malware", "trojan"],
  reaction: "ğŸª…",
  categorie: "Fun"
}, async (dest, zk, commandeOptions) => {
  try {
    const { ms } = commandeOptions;
    const mek = ms; // The message object for quoting

    // Define the steps of the prank
    const steps = [
      "```Injecting Malware```",
      "``` â–ˆ 10%```",
      "```â–ˆ â–ˆ 20%```",
      "```â–ˆ â–ˆ â–ˆ 30%```",
      "``` â–ˆ â–ˆ â–ˆ â–ˆ 40%```",
      "``` â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ 50%```",
      "``` â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ 60%```",
      "``` â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ 70%```",
      "```â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ 80%```",
      "```â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ 90%```",
      "```â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ 100%```",
      "```System hijacking on process..```",
      "```Connecting to Server error to find 404```",
      "```Device successfully connected...\nReceiving data...```",
      "```Data hijacked from device 100% completed\nKilling all evidence, killing all malwares...```",
      "```HACKING COMPLETED```",
      "```SENDING LOG DOCUMENTS...```",
      "```SUCCESSFULLY SENT DATA AND Connection disconnected```",
      "```BACKLOGS CLEARED```",
      "```POWERED BY ALONE MD```",
      "```paralyzed by the mighty ```"*${conf.OWNER_NAME}*
    ];

    // Loop through all the steps and send them
    for (const line of steps) {
      await zk.sendMessage(dest, { text: line }, { quoted: mek });
      await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for effect
    }

  } catch (error) {
    console.error('Error during prank:', error);
    // Send a more detailed error message
    await zk.sendMessage(dest, {
      text: `âŒ *Error!* Something went wrong. Reason: ${error.message}. Please try again later.`
    });
  }
});


zokou({
  nomCom: "happy",
  categorie: "fun",
  reaction: "ğŸ“½ï¸"
}, async (dest, zk, commandeOptions) => {
  const { repondre, ms } = commandeOptions;
  
  try {
    const sentMessage = await zk.sendMessage(dest, { text: "âœŠğŸ» *STARTED...* ğŸ’¦" });
    const animations =  ['ğŸ˜ƒ', 'ğŸ˜„', 'ğŸ˜', 'ğŸ˜Š', 'ğŸ˜', 'ğŸ¥³', 'ğŸ˜¸', 'ğŸ˜¹', 'ğŸŒ', 'ğŸŒˆ', 'ğŸ˜ƒ', 'ğŸ˜„', 'ğŸ˜', 'ğŸ˜Š', 'ğŸ˜', 'ğŸ¥³', 'ğŸ˜¸', 'ğŸ˜¹', 'ğŸŒ', 'ğŸŒˆ', 'ğŸ˜ƒ', 'ğŸ˜„', 'ğŸ˜', 'ğŸ˜Š'];
    for (const animation of animations) {
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      await zk.relayMessage(dest, {
        protocolMessage: {
          key: sentMessage.key,
          type: 14, // Protocol message type for edited message
          editedMessage: {
            conversation: animation
          }
        }
      }, {});
    }
  } catch (error) {
    console.log(error);
    repondre("âŒ *Error!* " + error.message);
  }
});
zokou({
  nomCom: "hrt",
  aliases: ["moyo", "heart"],
  categorie: "fun",
  reaction: "ğŸ“½ï¸"
}, async (dest, zk, commandeOptions) => {
  const { repondre, ms } = commandeOptions;
  
  try {
    const sentMessage = await zk.sendMessage(dest, { text: "âœŠğŸ» *STARTED...* ğŸ’¦" });
    const animations =  ['ğŸ’–', 'ğŸ’—', 'ğŸ’•', 'â¤ï¸', 'ğŸ’›', 'ğŸ’š', 'ğŸ«€', 'ğŸ’™', 'ğŸ’œ', 'ğŸ–¤', 'â™¥ï¸', 'ğŸ¤', 'ğŸ¤', 'ğŸ’—', 'ğŸ’', 'ğŸ’“', 'ğŸ’˜', 'ğŸ’', 'â™¥ï¸', 'ğŸ’Ÿ', 'ğŸ«€', 'â¤ï¸'];
    for (const animation of animations) {
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      await zk.relayMessage(dest, {
        protocolMessage: {
          key: sentMessage.key,
          type: 14, // Protocol message type for edited message
          editedMessage: {
            conversation: animation
          }
        }
      }, {});
    }
  } catch (error) {
    console.log(error);
    repondre("âŒ *Error!* " + error.message);
  }
});
zokou({
  nomCom: "angry1",
  categorie: "fun",
  reaction: "ğŸ“½ï¸"
}, async (dest, zk, commandeOptions) => {
  const { repondre, ms } = commandeOptions;
  
  try {
    const sentMessage = await zk.sendMessage(dest, { text: "âœŠğŸ» *STARTED...* ğŸ’¦" });
    const animations =   ['ğŸ˜¡', 'ğŸ˜ ', 'ğŸ¤¬', 'ğŸ˜¤', 'ğŸ˜¾', 'ğŸ˜¡', 'ğŸ˜ ', 'ğŸ¤¬', 'ğŸ˜¤', 'ğŸ˜¾'];
    for (const animation of animations) {
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      await zk.relayMessage(dest, {
        protocolMessage: {
          key: sentMessage.key,
          type: 14, // Protocol message type for edited message
          editedMessage: {
            conversation: animation
          }
        }
      }, {});
    }
  } catch (error) {
    console.log(error);
    repondre("âŒ *Error!* " + error.message);
  }
});
zokou({
  nomCom: "heartbroken",
  aliases: ["heartbroken", "hrtbroken"],
  categorie: "fun",
  reaction: "ğŸ“½ï¸"
}, async (dest, zk, commandeOptions) => {
  const { repondre, ms } = commandeOptions;
  
  try {
    const sentMessage = await zk.sendMessage(dest, { text: "âœŠğŸ» *STARTED...* ğŸ’¦" });
    const animations =  ['ğŸ¥º', 'ğŸ˜Ÿ', 'ğŸ˜•', 'ğŸ˜–', 'ğŸ˜«', 'ğŸ™', 'ğŸ˜©', 'ğŸ˜¥', 'ğŸ˜“', 'ğŸ˜ª', 'ğŸ˜¢', 'ğŸ˜”', 'ğŸ˜', 'ğŸ˜­', 'ğŸ’”', 'ğŸ˜­', 'ğŸ˜¿'];
    for (const animation of animations) {
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      await zk.relayMessage(dest, {
        protocolMessage: {
          key: sentMessage.key,
          type: 14, // Protocol message type for edited message
          editedMessage: {
            conversation: animation
          }
        }
      }, {});
    }
  } catch (error) {
    console.log(error);
    repondre("âŒ *Error!* " + error.message);
  }
});
zokou({
  nomCom: "shy",
  aliases: ["shyoff", "shyy"],
  categorie: "fun",
  reaction: "ğŸ¥º"
}, async (dest, zk, commandeOptions) => {
  const { repondre, ms } = commandeOptions;
  
  try {
    const sentMessage = await zk.sendMessage(dest, { text: "âœŠğŸ» *STARTED...* ğŸ’¦" });
    const animations =  ['ğŸ˜³', 'ğŸ˜Š', 'ğŸ˜¶', 'ğŸ™ˆ', 'ğŸ™Š', 'ğŸ˜³', 'ğŸ˜Š', 'ğŸ˜¶', 'ğŸ™ˆ', 'ğŸ™Š'];
    for (const animation of animations) {
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      await zk.relayMessage(dest, {
        protocolMessage: {
          key: sentMessage.key,
          type: 14, // Protocol message type for edited message
          editedMessage: {
            conversation: animation
          }
        }
      }, {});
    }
  } catch (error) {
    console.log(error);
    repondre("âŒ *Error!* " + error.message);
  }
});
zokou({
  nomCom: "moon",
  aliases: ["mon", "crescent"],
  categorie: "fun",
  reaction: "ğŸ™ƒ"
}, async (dest, zk, commandeOptions) => {
  const { repondre, ms } = commandeOptions;
  
  try {
    const sentMessage = await zk.sendMessage(dest, { text: "âœŠğŸ» *STARTED...* ğŸ’¦" });
    const animations =   ['ğŸŒ—', 'ğŸŒ˜', 'ğŸŒ‘', 'ğŸŒ’', 'ğŸŒ“', 'ğŸŒ”', 'ğŸŒ•', 'ğŸŒ–', 'ğŸŒ—', 'ğŸŒ˜', 'ğŸŒ‘', 'ğŸŒ’', 'ğŸŒ“', 'ğŸŒ”', 'ğŸŒ•', 'ğŸŒ–', 'ğŸŒ—', 'ğŸŒ˜', 'ğŸŒ‘', 'ğŸŒ’', 'ğŸŒ“', 'ğŸŒ”', 'ğŸŒ•', 'ğŸŒ–', 'ğŸŒ—', 'ğŸŒ˜', 'ğŸŒ‘', 'ğŸŒ’', 'ğŸŒ“', 'ğŸŒ”', 'ğŸŒ•', "ğŸŒšğŸŒ"];
    for (const animation of animations) {
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      await zk.relayMessage(dest, {
        protocolMessage: {
          key: sentMessage.key,
          type: 14, // Protocol message type for edited message
          editedMessage: {
            conversation: animation
          }
        }
      }, {});
    }
  } catch (error) {
    console.log(error);
    repondre("âŒ *Error!* " + error.message);
  }
});

zokou({
  nomCom: "nikal",
  categorie: "fun",
  reaction: "ğŸ¥±"
}, async (dest, zk, commandeOptions) => {
  const { repondre, ms } = commandeOptions;
  
  try {
    const sentMessage = await zk.sendMessage(dest, { text: "âœŠğŸ» *STARTED...* ğŸ’¦" });
    const animations = ["   â£ â£¶â¡¾â â ‰â ™â ³â¢¦â¡€   â¢ â â ‰â ™â ²â¡€ \n  â£´â ¿â           â¢³â¡€ â¡         â¢·\nâ¢ â£Ÿâ£‹â¡€â¢€â£€â£€â¡€ â£€â¡€   â£§ â¢¸          â¡‡\nâ¢¸â£¯â¡­â â ¸â£›â£Ÿâ †â¡´â£»â¡²     â£¿  â£¸   Nikal   â¡‡\n â£Ÿâ£¿â¡­     â¢±        â£¿  â¢¹           â¡‡\n  â ™â¢¿â£¯â „   __        â¡¿  â¡‡        â¡¼\n   â ¹â£¶â †     â¡´â ƒ    â ˜â ¤â£„â£ â  \n    â¢¸â£·â¡¦â¢¤â¡¤â¢¤â£â£          \n â¢€â£¤â£´â£¿â£â   â ¸â£â¢¯â£·â£–â£¦â¡€      \nâ¢€â£¾â£½â£¿â£¿â£¿â£¿â ›â¢²â£¶â£¾â¢‰â¡·â£¿â£¿â µâ£¿      \nâ£¼â£¿â â ‰â£¿â¡­â ‰â ™â¢ºâ£‡â£¼â¡    â£„â¢¸      `", "   â£ â£¶â¡¾â â ‰â ™â ³â¢¦â¡€   â¢ â â ‰â ™â ²â¡€ \n  â£´â ¿â           â¢³â¡€ â¡         â¢·\nâ¢ â£Ÿâ£‹â¡€â¢€â£€â£€â¡€ â£€â¡€   â£§ â¢¸          â¡‡\nâ¢¸â£¯â¡­â â ¸â£›â£Ÿâ †â¡´â£»â¡²     â£¿  â£¸   Lavde   â¡‡\n â£Ÿâ£¿â¡­     â¢±        â£¿  â¢¹           â¡‡\n  â ™â¢¿â£¯â „  |__|     â¡¿  â¡‡        â¡¼\n   â ¹â£¶â †     â¡´â ƒ    â ˜â ¤â£„â£ â  \n    â¢¸â£·â¡¦â¢¤â¡¤â¢¤â£â£          \n â¢€â£¤â£´â£¿â£â   â ¸â£â¢¯â£·â£–â£¦â¡€      \nâ¢€â£¾â£½â£¿â£¿â£¿â£¿â ›â¢²â£¶â£¾â¢‰â¡·â£¿â£¿â µâ£¿      \nâ£¼â£¿â â ‰â£¿â¡­â ‰â ™â¢ºâ£‡â£¼â¡    â£„â¢¸      `", "   â£ â£¶â¡¾â â ‰â ™â ³â¢¦â¡€   â¢ â â ‰â ™â ²â¡€ \n  â£´â ¿â            â¢³â¡€ â¡         â¢·\nâ¢ â£Ÿâ£‹â¡€â¢€â£€â£€â¡€ â£€â¡€   â£§ â¢¸          â¡‡\nâ¢¸â£¯â¡­â â ¸â£›â£Ÿâ †â¡´â£»â¡²    â£¿  â£¸   Pehli   â¡‡\n â£Ÿâ£¿â¡­     â¢±       â£¿  â¢¹            â¡‡\n  â ™â¢¿â£¯â „  (P)       â¡¿  â¡‡        â¡¼\n   â ¹â£¶â †     â¡´â ƒ    â ˜â ¤â£„â£ â  \n    â¢¸â£·â¡¦â¢¤â¡¤â¢¤â£â£          \n â¢€â£¤â£´â£¿â£â   â ¸â£â¢¯â£·â£–â£¦â¡€      \nâ¢€â£¾â£½â£¿â£¿â£¿â£¿â ›â¢²â£¶â£¾â¢‰â¡·â£¿â£¿â µâ£¿      \nâ£¼â£¿â â ‰â£¿â¡­â ‰â ™â¢ºâ£‡â£¼â¡    â£„â¢¸      `", "   â£ â£¶â¡¾â â ‰â ™â ³â¢¦â¡€   â¢ â â ‰â ™â ²â¡€ \n  â£´â ¿â            â¢³â¡€ â¡         â¢·\nâ¢ â£Ÿâ£‹â¡€â¢€â£€â£€â¡€ â£€â¡€   â£§ â¢¸          â¡‡\nâ¢¸â£¯â¡­â â ¸â£›â£Ÿâ †â¡´â£»â¡²    â£¿  â£¸  Fursat  â¡‡\n â£Ÿâ£¿â¡­     â¢±         â£¿  â¢¹           â¡‡\n  â ™â¢¿â£¯â „   __        â¡¿  â¡‡        â¡¼\n   â ¹â£¶â †     â¡´â ƒ    â ˜â ¤â£„â£ â  \n    â¢¸â£·â¡¦â¢¤â¡¤â¢¤â£â£          \n â¢€â£¤â£´â£¿â£â   â ¸â£â¢¯â£·â£–â£¦â¡€      \nâ¢€â£¾â£½â£¿â£¿â£¿â£¿â ›â¢²â£¶â£¾â¢‰â¡·â£¿â£¿â µâ£¿      \nâ£¼â£¿â â ‰â£¿â¡­â ‰â ™â¢ºâ£‡â£¼â¡    â£„â¢¸      `", "   â£ â£¶â¡¾â â ‰â ™â ³â¢¦â¡€   â¢ â â ‰â ™â ²â¡€ \n  â£´â ¿â            â¢³â¡€ â¡         â¢·\nâ¢ â£Ÿâ£‹â¡€â¢€â£€â£€â¡€ â£€â¡€   â£§ â¢¸          â¡‡\nâ¢¸â£¯â¡­â â ¸â£›â£Ÿâ †â¡´â£»â¡²    â£¿  â£¸  Meeee   â¡‡\n â£Ÿâ£¿â¡­     â¢±         â£¿  â¢¹           â¡‡\n  â ™â¢¿â£¯â „  |__|      â¡¿  â¡‡        â¡¼\n   â ¹â£¶â †     â¡´â ƒ    â ˜â ¤â£„â£ â  \n    â¢¸â£·â¡¦â¢¤â¡¤â¢¤â£â£          \n â¢€â£¤â£´â£¿â£â   â ¸â£â¢¯â£·â£–â£¦â¡€      \nâ¢€â£¾â£½â£¿â£¿â£¿â£¿â ›â¢²â£¶â£¾â¢‰â¡·â£¿â£¿â µâ£¿      \nâ£¼â£¿â â ‰â£¿â¡­â ‰â ™â¢ºâ£‡â£¼â¡    â£„â¢¸      `", "   â£ â£¶â¡¾â â ‰â ™â ³â¢¦â¡€   â¢ â â ‰â ™â ²â¡€ \n  â£´â ¿â            â¢³â¡€ â¡         â¢·\nâ¢ â£Ÿâ£‹â¡€â¢€â£€â£€â¡€ â£€â¡€   â£§ â¢¸           â¡‡\nâ¢¸â£¯â¡­â â ¸â£›â£Ÿâ †â¡´â£»â¡²   â£¿  â£¸   Nikal   â¡‡\n â£Ÿâ£¿â¡­     â¢±        â£¿  â¢¹            â¡‡\n  â ™â¢¿â£¯â „  lodu     â¡¿  â¡‡       â¡¼\n   â ¹â£¶â †       â¡´â ƒ    â ˜â ¤â£„â£ â  \n    â¢¸â£·â¡¦â¢¤â¡¤â¢¤â£â£          \n â¢€â£¤â£´â£¿â£â   â ¸â£â¢¯â£·â£–â£¦â¡€      \nâ¢€â£¾â£½â£¿â£¿â£¿â£¿â ›â¢²â£¶â£¾â¢‰â¡·â£¿â£¿â µâ£¿      \nâ£¼â£¿â â ‰â£¿â¡­â ‰â ™â¢ºâ£‡â£¼â¡    â£„â¢¸ "];

    for (const animation of animations) {
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      await zk.relayMessage(dest, {
        protocolMessage: {
          key: sentMessage.key,
          type: 14, // Protocol message type for edited message
          editedMessage: {
            conversation: animation
          }
        }
      }, {});
    }
  } catch (error) {
    console.log(error);
    repondre("âŒ *Error!* " + error.message);
  }
});

zokou({
  nomCom: "hand",
  categorie: "fun",
  reaction: "ğŸ“½ï¸"
}, async (dest, zk, commandeOptions) => {
  const { repondre, ms } = commandeOptions;
  
  try {
    const sentMessage = await zk.sendMessage(dest, { text: "âœŠğŸ» *STARTED...* ğŸ’¦" });
    const animations = [
      '8âœŠï¸===D', '8=âœŠï¸==D', '8==âœŠï¸=D', '8===âœŠï¸D', '8==âœŠï¸=D', '8=âœŠï¸==D', 
      '8âœŠï¸===D', '8=âœŠï¸==D', '8==âœŠï¸=D', '8===âœŠï¸D', '8==âœŠï¸=D', '8=âœŠï¸==D', 
      '8âœŠï¸===D', '8=âœŠï¸==D', '8==âœŠï¸=D', '8===âœŠï¸D', '8==âœŠï¸=D', '8=âœŠï¸==D', 
      '8âœŠï¸===D', '8=âœŠï¸==D', '8==âœŠï¸=D', '8===âœŠï¸D ğŸ’¦', '8==âœŠï¸=DğŸ’¦ ğŸ’¦', '8=âœŠï¸==D ğŸ’¦ğŸ’¦ ğŸ’¦'
    ];

    for (const animation of animations) {
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      await zk.relayMessage(dest, {
        protocolMessage: {
          key: sentMessage.key,
          type: 14, // Protocol message type for edited message
          editedMessage: {
            conversation: animation
          }
        }
      }, {});
    }
  } catch (error) {
    console.log(error);
    repondre("âŒ *Error!* " + error.message);
  }
});
